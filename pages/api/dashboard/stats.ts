import type { NextApiRequest, NextApiResponse } from "next";
import { authenticateRequest } from "@utils/api-helpers";
import { getOrCreateUser } from "@core/database/queries/users";
import { db, users, projects, forumPosts, meetingNotes, innovationBounties, documents, projectCollaborators } from "@core/database";
import { sql, eq, desc, isNull, or } from "drizzle-orm";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (req.method !== "GET") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const claims = await authenticateRequest(req);
    const privyDid = claims.userId;
    const email = (claims as any).email || undefined;

    const user = await getOrCreateUser(privyDid, email);

    const totalUsersResult = await db
      .select({ count: sql<number>`COUNT(*)` })
      .from(users);
    const totalUsers = totalUsersResult[0]?.count || 0;

    const totalProjectsResult = await db
      .select({ count: sql<number>`COUNT(*)` })
      .from(projects);
    const totalProjects = totalProjectsResult[0]?.count || 0;

    const activeProjectsData = await db
      .select({
        id: projects.id,
        title: projects.title,
        status: projects.status,
        creator_name: users.username,
        creator_id: projects.creatorId,
        created_at: projects.createdAt,
        updated_at: projects.updatedAt,
        collaborators: sql<number>`COALESCE(
          (SELECT COUNT(*) + 1 FROM project_collaborators WHERE project_id = ${projects.id}), 
          1
        )`,
        is_user_involved: sql<number>`CASE 
          WHEN ${projects.creatorId} = ${user!.id} THEN 1
          WHEN EXISTS (
            SELECT 1 FROM project_collaborators 
            WHERE project_id = ${projects.id} AND user_id = ${user!.id}
          ) THEN 1
          ELSE 0
        END`,
      })
      .from(projects)
      .leftJoin(users, eq(projects.creatorId, users.id))
      .where(eq(projects.status, "active"))
      .orderBy(desc(projects.updatedAt))
      .limit(10);

    const userActiveProjects = await db
      .select({
        id: projects.id,
        title: projects.title,
        status: projects.status,
        creator_name: users.username,
        creator_id: projects.creatorId,
        created_at: projects.createdAt,
        updated_at: projects.updatedAt,
        collaborators: sql<number>`COALESCE(
          (SELECT COUNT(*) + 1 FROM project_collaborators WHERE project_id = ${projects.id}), 
          1
        )`,
        user_role: sql<string>`CASE 
          WHEN ${projects.creatorId} = ${user!.id} THEN 'creator'
          ELSE COALESCE(
            (SELECT role FROM project_collaborators 
             WHERE project_id = ${projects.id} AND user_id = ${user!.id}),
            'none'
          )
        END`,
      })
      .from(projects)
      .leftJoin(users, eq(projects.creatorId, users.id))
      .leftJoin(projectCollaborators, eq(projectCollaborators.projectId, projects.id))
      .where(
        or(
          eq(projects.creatorId, user!.id),
          eq(projectCollaborators.userId, user!.id)
        )
      )
      .orderBy(desc(projects.updatedAt))
      .limit(10);

    const latestForumPosts = await db
      .select({
        id: forumPosts.id,
        title: forumPosts.title,
        category: forumPosts.category,
        author_name: users.username,
        created_at: forumPosts.createdAt,
        reply_count: sql<number>`COALESCE(
          (SELECT COUNT(*) FROM forum_posts AS replies 
           WHERE replies.parent_id = ${forumPosts.id}), 
          0
        )`,
        upvotes: sql<number>`COALESCE(
          (SELECT SUM(vote_type) FROM forum_votes WHERE post_id = ${forumPosts.id}), 
          0
        )`,
      })
      .from(forumPosts)
      .leftJoin(users, eq(forumPosts.authorId, users.id))
      .where(isNull(forumPosts.parentId))
      .orderBy(desc(forumPosts.createdAt))
      .limit(5);

    const innovationAssetsRanking = await db
      .select({
        id: innovationBounties.id,
        title: innovationBounties.title,
        bountyAmount: innovationBounties.bountyAmount,
        status: innovationBounties.status,
        proposalCount: innovationBounties.proposalCount,
        category: innovationBounties.category,
      })
      .from(innovationBounties)
      .where(eq(innovationBounties.status, "published"))
      .orderBy(desc(innovationBounties.bountyAmount))
      .limit(5);

    const latestMeetingNote = await db
      .select({
        id: meetingNotes.id,
        title: meetingNotes.title,
        date: meetingNotes.date,
        author_name: users.username,
        notes: meetingNotes.notes,
        created_at: meetingNotes.createdAt,
      })
      .from(meetingNotes)
      .leftJoin(users, eq(meetingNotes.authorId, users.id))
      .orderBy(desc(meetingNotes.date))
      .limit(1);

    const totalDocumentsResult = await db
      .select({ count: sql<number>`COUNT(*)` })
      .from(documents)
      .where(eq(documents.status, "active"));
    const totalDocuments = totalDocumentsResult[0]?.count || 0;

    const uniqueUserProjects = Array.from(
      new Map(userActiveProjects.map(p => [p.id, p])).values()
    ).filter(p => p.user_role !== 'none');

    return res.status(200).json({
      totalUsers,
      totalDocuments,
      totalProjects,
      activeProjects: activeProjectsData,
      userActiveProjects: uniqueUserProjects,
      latestForumPosts,
      innovationAssetsRanking,
      latestMeetingNote: latestMeetingNote[0] || null,
    });
  } catch (error: any) {
    console.error("Dashboard stats API error:", error);
    return res.status(500).json({ error: error.message || "Internal server error" });
  }
}
